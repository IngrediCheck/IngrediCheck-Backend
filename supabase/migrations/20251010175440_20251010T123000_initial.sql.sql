create sequence "public"."dietary_preferences_id_seq";

create table "public"."dashboard_access_logs" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "action" text not null,
    "resource" text not null,
    "success" boolean not null,
    "timestamp" timestamp with time zone default now(),
    "ip_address" inet,
    "user_agent" text
);


alter table "public"."dashboard_access_logs" enable row level security;

create table "public"."dietary_preferences" (
    "user_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "deleted_at" timestamp with time zone,
    "id" integer not null default nextval('dietary_preferences_id_seq'::regclass),
    "text" text,
    "annotated_text" text
);


alter table "public"."dietary_preferences" enable row level security;

create table "public"."log_analyzebarcode" (
    "activity_id" uuid not null,
    "user_id" uuid not null,
    "client_activity_id" uuid,
    "created_at" timestamp with time zone not null default now(),
    "start_time" timestamp with time zone not null,
    "end_time" timestamp with time zone not null,
    "request_body" json not null,
    "response_status" integer not null,
    "response_body" json not null
);


alter table "public"."log_analyzebarcode" enable row level security;

create table "public"."log_extract" (
    "user_id" uuid not null,
    "client_activity_id" uuid,
    "activity_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "start_time" timestamp with time zone not null,
    "end_time" timestamp with time zone not null,
    "barcode" text,
    "name" text,
    "brand" text,
    "ingredients" json,
    "response_status" integer not null,
    "images" text[]
);


alter table "public"."log_extract" enable row level security;

create table "public"."log_feedback" (
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "client_activity_id" uuid not null,
    "activity_id" uuid not null,
    "rating" integer not null,
    "reasons" text[],
    "note" text,
    "images" text[]
);


alter table "public"."log_feedback" enable row level security;

create table "public"."log_images" (
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "client_activity_id" uuid not null,
    "activity_id" uuid not null,
    "image_file_hash" text not null,
    "image_ocrtext_ios" text not null,
    "barcode_ios" text
);


alter table "public"."log_images" enable row level security;

create table "public"."log_inventory" (
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "barcode" text not null,
    "data_source" text not null,
    "name" text,
    "brand" text,
    "ingredients" json,
    "images" json,
    "client_activity_id" uuid,
    "start_time" timestamp with time zone,
    "end_time" timestamp with time zone
);


alter table "public"."log_inventory" enable row level security;

create table "public"."log_llmcall" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "activity_id" uuid not null,
    "user_id" uuid not null,
    "conversation_id" uuid not null,
    "parentconversation_ids" uuid[],
    "start_time" timestamp with time zone not null,
    "end_time" timestamp with time zone not null,
    "agent_name" text not null,
    "model_provider" text not null,
    "model_name" text not null,
    "temperature" numeric not null,
    "function_call" text not null,
    "functions" json not null,
    "messages" json not null,
    "response" json,
    "client_activity_id" uuid
);


alter table "public"."log_llmcall" enable row level security;

create table "public"."log_preference_validation" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "input_text" text not null,
    "output_interpretation" jsonb not null,
    "latency_ms" integer,
    "created_at" timestamp with time zone not null default now(),
    "client_activity_id" uuid
);


alter table "public"."log_preference_validation" enable row level security;

create table "public"."recorded_sessions" (
    "id" bigint generated by default as identity not null,
    "recording_session_id" text not null,
    "user_id" uuid not null,
    "recorded_at" timestamp with time zone not null default now(),
    "request_method" text not null,
    "request_path" text not null,
    "request_headers" jsonb not null default '{}'::jsonb,
    "request_body" jsonb,
    "response_status" integer not null,
    "response_headers" jsonb not null default '{}'::jsonb,
    "response_body" jsonb
);


alter table "public"."recorded_sessions" enable row level security;

create table "public"."review_assignments" (
    "id" uuid not null default gen_random_uuid(),
    "thread_id" uuid not null,
    "reviewer_id" uuid not null,
    "assigned_by" uuid,
    "assigned_at" timestamp with time zone not null default now(),
    "completed_at" timestamp with time zone
);


alter table "public"."review_assignments" enable row level security;

create table "public"."review_comments" (
    "id" uuid not null default gen_random_uuid(),
    "thread_id" uuid not null,
    "user_id" uuid not null,
    "comment" text not null,
    "action" text,
    "metadata" jsonb,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."review_comments" enable row level security;

create table "public"."review_threads" (
    "id" uuid not null default gen_random_uuid(),
    "source_table" text not null,
    "source_id" text not null,
    "thread_type" text not null,
    "status" text not null default 'unreviewed'::text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "created_by" uuid
);


alter table "public"."review_threads" enable row level security;

create table "public"."role_audit_log" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "action" text not null,
    "old_role" text,
    "new_role" text,
    "changed_by" uuid,
    "changed_at" timestamp with time zone default now(),
    "ip_address" inet,
    "user_agent" text
);


alter table "public"."role_audit_log" enable row level security;

create table "public"."user_list_items" (
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "list_id" uuid not null,
    "list_item_id" uuid not null
);


alter table "public"."user_list_items" enable row level security;

create table "public"."user_roles" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "role" text not null,
    "assigned_by" uuid,
    "assigned_at" timestamp with time zone default now(),
    "expires_at" timestamp with time zone,
    "is_active" boolean default true,
    "notes" text
);


alter table "public"."user_roles" enable row level security;

alter sequence "public"."dietary_preferences_id_seq" owned by "public"."dietary_preferences"."id";

CREATE UNIQUE INDEX dashboard_access_logs_pkey ON public.dashboard_access_logs USING btree (id);

CREATE UNIQUE INDEX dietary_preferences_pkey ON public.dietary_preferences USING btree (id);

CREATE UNIQUE INDEX log_agents_key ON public.log_llmcall USING btree (id);

CREATE UNIQUE INDEX log_extract_key ON public.log_extract USING btree (activity_id);

CREATE UNIQUE INDEX log_feedback_key ON public.log_feedback USING btree (client_activity_id);

CREATE UNIQUE INDEX log_images_key ON public.log_images USING btree (image_file_hash);

CREATE UNIQUE INDEX log_infer_key ON public.log_analyzebarcode USING btree (activity_id);

CREATE UNIQUE INDEX log_preference_validation_pkey ON public.log_preference_validation USING btree (id);

CREATE UNIQUE INDEX recorded_sessions_pkey ON public.recorded_sessions USING btree (id);

CREATE INDEX recorded_sessions_session_idx ON public.recorded_sessions USING btree (recording_session_id);

CREATE UNIQUE INDEX review_assignments_pkey ON public.review_assignments USING btree (id);

CREATE UNIQUE INDEX review_assignments_thread_id_reviewer_id_key ON public.review_assignments USING btree (thread_id, reviewer_id);

CREATE UNIQUE INDEX review_comments_pkey ON public.review_comments USING btree (id);

CREATE UNIQUE INDEX review_threads_pkey ON public.review_threads USING btree (id);

CREATE UNIQUE INDEX review_threads_source_table_source_id_key ON public.review_threads USING btree (source_table, source_id);

CREATE UNIQUE INDEX role_audit_log_pkey ON public.role_audit_log USING btree (id);

CREATE UNIQUE INDEX user_list_items_pkey ON public.user_list_items USING btree (list_item_id);

CREATE UNIQUE INDEX user_roles_pkey ON public.user_roles USING btree (id);

CREATE UNIQUE INDEX user_roles_user_id_key ON public.user_roles USING btree (user_id);

alter table "public"."dashboard_access_logs" add constraint "dashboard_access_logs_pkey" PRIMARY KEY using index "dashboard_access_logs_pkey";

alter table "public"."dietary_preferences" add constraint "dietary_preferences_pkey" PRIMARY KEY using index "dietary_preferences_pkey";

alter table "public"."log_analyzebarcode" add constraint "log_infer_key" PRIMARY KEY using index "log_infer_key";

alter table "public"."log_extract" add constraint "log_extract_key" PRIMARY KEY using index "log_extract_key";

alter table "public"."log_feedback" add constraint "log_feedback_key" PRIMARY KEY using index "log_feedback_key";

alter table "public"."log_images" add constraint "log_images_key" PRIMARY KEY using index "log_images_key";

alter table "public"."log_llmcall" add constraint "log_agents_key" PRIMARY KEY using index "log_agents_key";

alter table "public"."log_preference_validation" add constraint "log_preference_validation_pkey" PRIMARY KEY using index "log_preference_validation_pkey";

alter table "public"."recorded_sessions" add constraint "recorded_sessions_pkey" PRIMARY KEY using index "recorded_sessions_pkey";

alter table "public"."review_assignments" add constraint "review_assignments_pkey" PRIMARY KEY using index "review_assignments_pkey";

alter table "public"."review_comments" add constraint "review_comments_pkey" PRIMARY KEY using index "review_comments_pkey";

alter table "public"."review_threads" add constraint "review_threads_pkey" PRIMARY KEY using index "review_threads_pkey";

alter table "public"."role_audit_log" add constraint "role_audit_log_pkey" PRIMARY KEY using index "role_audit_log_pkey";

alter table "public"."user_list_items" add constraint "user_list_items_pkey" PRIMARY KEY using index "user_list_items_pkey";

alter table "public"."user_roles" add constraint "user_roles_pkey" PRIMARY KEY using index "user_roles_pkey";

alter table "public"."dashboard_access_logs" add constraint "dashboard_access_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."dashboard_access_logs" validate constraint "dashboard_access_logs_user_id_fkey";

alter table "public"."log_preference_validation" add constraint "log_preference_validation_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."log_preference_validation" validate constraint "log_preference_validation_user_id_fkey";

alter table "public"."review_assignments" add constraint "review_assignments_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES auth.users(id) not valid;

alter table "public"."review_assignments" validate constraint "review_assignments_assigned_by_fkey";

alter table "public"."review_assignments" add constraint "review_assignments_reviewer_id_fkey" FOREIGN KEY (reviewer_id) REFERENCES auth.users(id) not valid;

alter table "public"."review_assignments" validate constraint "review_assignments_reviewer_id_fkey";

alter table "public"."review_assignments" add constraint "review_assignments_thread_id_fkey" FOREIGN KEY (thread_id) REFERENCES review_threads(id) ON DELETE CASCADE not valid;

alter table "public"."review_assignments" validate constraint "review_assignments_thread_id_fkey";

alter table "public"."review_assignments" add constraint "review_assignments_thread_id_reviewer_id_key" UNIQUE using index "review_assignments_thread_id_reviewer_id_key";

alter table "public"."review_comments" add constraint "review_comments_action_check" CHECK ((action = ANY (ARRAY['comment'::text, 'status_change'::text, 'expected_output'::text]))) not valid;

alter table "public"."review_comments" validate constraint "review_comments_action_check";

alter table "public"."review_comments" add constraint "review_comments_thread_id_fkey" FOREIGN KEY (thread_id) REFERENCES review_threads(id) ON DELETE CASCADE not valid;

alter table "public"."review_comments" validate constraint "review_comments_thread_id_fkey";

alter table "public"."review_comments" add constraint "review_comments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."review_comments" validate constraint "review_comments_user_id_fkey";

alter table "public"."review_threads" add constraint "review_threads_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."review_threads" validate constraint "review_threads_created_by_fkey";

alter table "public"."review_threads" add constraint "review_threads_source_table_source_id_key" UNIQUE using index "review_threads_source_table_source_id_key";

alter table "public"."review_threads" add constraint "review_threads_status_check" CHECK ((status = ANY (ARRAY['unreviewed'::text, 'promoted'::text, 'reviewed'::text, 'need_review'::text]))) not valid;

alter table "public"."review_threads" validate constraint "review_threads_status_check";

alter table "public"."review_threads" add constraint "review_threads_thread_type_check" CHECK ((thread_type = ANY (ARRAY['preference_validation'::text, 'analyze_llm'::text, 'extract_llm'::text, 'manual_review'::text, 'preference_review'::text, 'barcode_review'::text, 'extract_review'::text]))) not valid;

alter table "public"."review_threads" validate constraint "review_threads_thread_type_check";

alter table "public"."role_audit_log" add constraint "role_audit_log_changed_by_fkey" FOREIGN KEY (changed_by) REFERENCES auth.users(id) not valid;

alter table "public"."role_audit_log" validate constraint "role_audit_log_changed_by_fkey";

alter table "public"."role_audit_log" add constraint "role_audit_log_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."role_audit_log" validate constraint "role_audit_log_user_id_fkey";

alter table "public"."user_roles" add constraint "user_roles_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES auth.users(id) not valid;

alter table "public"."user_roles" validate constraint "user_roles_assigned_by_fkey";

alter table "public"."user_roles" add constraint "user_roles_role_check" CHECK ((role = ANY (ARRAY['admin'::text, 'reviewer'::text]))) not valid;

alter table "public"."user_roles" validate constraint "user_roles_role_check";

alter table "public"."user_roles" add constraint "user_roles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_roles" validate constraint "user_roles_user_id_fkey";

alter table "public"."user_roles" add constraint "user_roles_user_id_key" UNIQUE using index "user_roles_user_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.analytics_analyze_latency(limit_count integer DEFAULT 100, min_latency_ms numeric DEFAULT 0, max_latency_ms numeric DEFAULT NULL::numeric)
 RETURNS TABLE(created_at timestamp with time zone, activity_id text, latency numeric, request_body jsonb, response_status integer, response_body jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  IF NOT is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Insufficient permissions';
  END IF;

  RETURN QUERY
  SELECT
    lab.created_at,
    lab.activity_id::text,
    ROUND(
      (
        (
          EXTRACT(EPOCH FROM lab.end_time) - EXTRACT(EPOCH FROM lab.start_time)
        ) * 1000
      )::numeric / 1000,
      3
    ) AS latency,
    lab.request_body,
    lab.response_status,
    lab.response_body
  FROM public.log_analyzebarcode lab
  WHERE (min_latency_ms IS NULL OR 
         ROUND(
           (
             (
               EXTRACT(EPOCH FROM lab.end_time) - EXTRACT(EPOCH FROM lab.start_time)
             ) * 1000
           )::numeric / 1000,
           3
         ) >= min_latency_ms)
    AND (max_latency_ms IS NULL OR 
         ROUND(
           (
             (
               EXTRACT(EPOCH FROM lab.end_time) - EXTRACT(EPOCH FROM lab.start_time)
             ) * 1000
           )::numeric / 1000,
           3
         ) <= max_latency_ms)
  ORDER BY lab.created_at DESC
  LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.analytics_analyze_latency_stats(days_back integer DEFAULT 30)
 RETURNS TABLE(total_requests bigint, avg_latency numeric, min_latency numeric, max_latency numeric, p95_latency numeric, p99_latency numeric, success_rate numeric, error_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  IF NOT is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Insufficient permissions';
  END IF;

  RETURN QUERY
  WITH latency_data AS (
    SELECT
      ROUND(
        (
          (
            EXTRACT(EPOCH FROM lab.end_time) - EXTRACT(EPOCH FROM lab.start_time)
          ) * 1000
        )::numeric / 1000,
        3
      ) AS latency,
      lab.response_status
    FROM public.log_analyzebarcode lab
    WHERE lab.created_at > CURRENT_DATE - (days_back || ' days')::interval
      AND lab.start_time IS NOT NULL 
      AND lab.end_time IS NOT NULL
  )
  SELECT
    COUNT(*)::bigint AS total_requests,
    ROUND(AVG(latency), 3) AS avg_latency,
    MIN(latency) AS min_latency,
    MAX(latency) AS max_latency,
    ROUND((PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY latency))::numeric, 3) AS p95_latency,
    ROUND((PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY latency))::numeric, 3) AS p99_latency,
    ROUND(
      (COUNT(*) FILTER (WHERE response_status = 200)::numeric / COUNT(*)) * 100, 
      2
    ) AS success_rate,
    COUNT(*) FILTER (WHERE response_status != 200) AS error_count
  FROM latency_data;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.analytics_inventory_latency(limit_count integer DEFAULT 100, min_latency_ms numeric DEFAULT 0, max_latency_ms numeric DEFAULT NULL::numeric, user_filter uuid DEFAULT NULL::uuid)
 RETURNS TABLE(created_at timestamp with time zone, user_id uuid, barcode text, data_source text, name text, brand text, ingredients text, images jsonb, client_activity_id text, latency numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  IF NOT is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Insufficient permissions';
  END IF;

  RETURN QUERY
  SELECT
    li.created_at,
    li.user_id,
    li.barcode::text,
    li.data_source::text,
    li.name::text,
    li.brand::text,
    li.ingredients::text,
    li.images,
    li.client_activity_id::text,
    ROUND(
      (
        (
          EXTRACT(EPOCH FROM li.end_time) - EXTRACT(EPOCH FROM li.start_time)
        ) * 1000
      )::numeric / 1000,
      3
    ) AS latency
  FROM public.log_inventory li
  WHERE (min_latency_ms IS NULL OR 
         ROUND(
           (
             (
               EXTRACT(EPOCH FROM li.end_time) - EXTRACT(EPOCH FROM li.start_time)
             ) * 1000
           )::numeric / 1000,
           3
         ) >= min_latency_ms)
    AND (max_latency_ms IS NULL OR 
         ROUND(
           (
             (
               EXTRACT(EPOCH FROM li.end_time) - EXTRACT(EPOCH FROM li.start_time)
             ) * 1000
           )::numeric / 1000,
           3
         ) <= max_latency_ms)
    AND (user_filter IS NULL OR li.user_id = user_filter)
  ORDER BY li.created_at DESC
  LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.analytics_inventory_latency_performance(days_back integer DEFAULT 30)
 RETURNS TABLE(data_source text, total_requests bigint, avg_latency numeric, min_latency numeric, max_latency numeric, success_rate numeric, total_images bigint, avg_images_per_request numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  IF NOT is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Insufficient permissions';
  END IF;

  RETURN QUERY
  WITH inventory_stats AS (
    SELECT
      li.data_source,
      ROUND(( (EXTRACT(EPOCH FROM li.end_time) - EXTRACT(EPOCH FROM li.start_time)) * 1000 )::numeric / 1000, 3) AS latency,
      li.images,
      CASE 
        WHEN li.name IS NOT NULL AND li.brand IS NOT NULL THEN 1 
        ELSE 0 
      END AS success_flag
    FROM public.log_inventory li
    WHERE li.created_at > CURRENT_DATE - (days_back || ' days')::interval
      AND li.start_time IS NOT NULL 
      AND li.end_time IS NOT NULL
  )
  SELECT
    istats.data_source::text,
    COUNT(*)::bigint AS total_requests,
    ROUND(AVG(istats.latency), 3) AS avg_latency,
    MIN(istats.latency) AS min_latency,
    MAX(istats.latency) AS max_latency,
    ROUND((SUM(istats.success_flag)::numeric / COUNT(*)) * 100, 2) AS success_rate,
    COUNT(istats.images) FILTER (WHERE istats.images IS NOT NULL) AS total_images,
    ROUND(
      AVG(
        CASE 
          WHEN istats.images IS NOT NULL AND json_typeof(istats.images) = 'array' THEN jsonb_array_length((istats.images)::jsonb)
          ELSE 0 
        END
      )::numeric, 2
    ) AS avg_images_per_request
  FROM inventory_stats istats
  GROUP BY istats.data_source
  ORDER BY avg_latency ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.analytics_new_users_per_day(start_date date DEFAULT NULL::date, end_date date DEFAULT CURRENT_DATE)
 RETURNS TABLE(registration_date date, new_users_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  min_date date;
BEGIN
  IF NOT is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Insufficient permissions';
  END IF;

  IF start_date IS NULL THEN
    SELECT MIN(DATE(created_at)) INTO min_date FROM auth.users;
  ELSE
    min_date := start_date;
  END IF;

  RETURN QUERY
  WITH all_dates AS (
    SELECT generate_series(min_date, end_date, '1 day'::interval)::date AS registration_date
  )
  SELECT
    ad.registration_date,
    COUNT(DISTINCT u.id) AS new_users_count
  FROM all_dates ad
  LEFT JOIN auth.users u ON DATE(u.created_at) = ad.registration_date
  GROUP BY ad.registration_date
  ORDER BY ad.registration_date DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.analytics_repeat_users(last_n_days integer DEFAULT 30, excluded_user_ids uuid[] DEFAULT '{}'::uuid[], provider_filter text DEFAULT 'apple'::text)
 RETURNS TABLE(email text, days_count integer, use_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  IF NOT is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Insufficient permissions';
  END IF;

  RETURN QUERY
  WITH recent_users AS (
    SELECT DISTINCT user_id
    FROM public.log_analyzebarcode
    WHERE created_at > CURRENT_DATE - (last_n_days || ' days')::interval
      AND NOT (user_id = ANY(excluded_user_ids))
  ),
  user_days_count AS (
    SELECT
      user_id,
      COUNT(DISTINCT DATE(created_at))::integer AS days_count,
      COUNT(*) AS use_count
    FROM public.log_analyzebarcode
    WHERE user_id IN (SELECT user_id FROM recent_users)
      AND created_at > CURRENT_DATE - (last_n_days || ' days')::interval
    GROUP BY user_id
  )
  SELECT
    (u.email)::text AS email,
    (udc.days_count)::integer AS days_count,
    udc.use_count
  FROM user_days_count udc
  JOIN auth.users u ON u.id = udc.user_id
  JOIN auth.identities i ON i.user_id = u.id
  WHERE (provider_filter IS NULL OR i.provider = provider_filter)
    AND udc.days_count > 1
  ORDER BY udc.days_count DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.assign_user_role(target_user_id uuid, new_role text, assigned_by_user_id uuid, notes text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    old_role TEXT;
    current_user_role TEXT;
BEGIN
    -- Check if current user can assign roles
    current_user_role := get_user_role(assigned_by_user_id);
    IF current_user_role != 'admin' THEN
        RAISE EXCEPTION 'Only admins can assign roles';
    END IF;
    
    -- Get old role for audit
    SELECT role INTO old_role FROM user_roles WHERE user_id = target_user_id;
    
    -- Insert or update role
    INSERT INTO user_roles (user_id, role, assigned_by, notes)
    VALUES (target_user_id, new_role, assigned_by_user_id, notes)
    ON CONFLICT (user_id) 
    DO UPDATE SET 
        role = EXCLUDED.role,
        assigned_by = EXCLUDED.assigned_by,
        assigned_at = NOW(),
        notes = EXCLUDED.notes;
    
    -- Log the change
    INSERT INTO role_audit_log (user_id, action, old_role, new_role, changed_by)
    VALUES (target_user_id, 'role_assigned', old_role, new_role, assigned_by_user_id);
    
    RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.barcode_review_count()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM public.log_analyzebarcode
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.barcode_review_list(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_status text DEFAULT 'all'::text)
 RETURNS TABLE(thread_id uuid, subject_id text, input_json text, output_json text, status text, latency_ms numeric, created_at timestamp with time zone, reviewer_ids uuid[], comment_count bigint, reviewers jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    rt.id AS thread_id,
    rt.source_id AS subject_id,
    jsonb_build_object(
      'barcode', lab.request_body->>'barcode',
      'userPreferenceText', lab.request_body->>'userPreferenceText',
      'product_name', li.name,
      'brand', li.brand
    )::text AS input_json,
    jsonb_build_object(
      'barcode', lab.request_body->>'barcode',
      'userPreferenceText', lab.request_body->>'userPreferenceText',
      'violations', COALESCE(lab.response_body::jsonb, '[]'::jsonb),
      'product', jsonb_build_object(
        'name', li.name,
        'brand', li.brand,
        'barcode', lab.request_body->>'barcode',
        'allIngredients', COALESCE(li.ingredients::jsonb, '[]'::jsonb),
        'images', COALESCE(li.images::jsonb, '[]'::jsonb)
      ),
      'matchStatus', CASE 
        WHEN lab.response_body IS NOT NULL AND lab.response_body::jsonb != '[]'::jsonb THEN 'unmatched'
        ELSE 'matched'
      END,
      'analysis_latency', COALESCE(EXTRACT(EPOCH FROM (lab.end_time - lab.start_time)) * 1000, 0)
    )::text AS output_json,
    COALESCE(rt.status, 'unreviewed') AS status,
    COALESCE(EXTRACT(EPOCH FROM (lab.end_time - lab.start_time)) * 1000, 0)::numeric AS latency_ms,
    lab.created_at,
    COALESCE(
      (SELECT array_agg(ra.reviewer_id)
       FROM public.review_assignments ra
       WHERE ra.thread_id = rt.id), 
      ARRAY[]::uuid[]
    ) AS reviewer_ids,
    COALESCE(
      (SELECT COUNT(*)
       FROM public.review_comments rc
       WHERE rc.thread_id = rt.id), 
      0
    )::bigint AS comment_count,
    COALESCE(
      (SELECT jsonb_agg(
        jsonb_build_object(
          'id', ra.reviewer_id,
          'email', 'reviewer@example.com',
          'assigned_at', ra.assigned_at
        )
      )
      FROM public.review_assignments ra
      WHERE ra.thread_id = rt.id), 
      '[]'::jsonb
    ) AS reviewers
  FROM public.review_threads rt
  INNER JOIN public.log_analyzebarcode lab ON lab.activity_id::text = rt.source_id
  LEFT JOIN public.log_inventory li ON li.barcode = lab.request_body->>'barcode'
  WHERE rt.source_table = 'log_analyzebarcode'
  AND (p_status = 'all' OR rt.status = p_status OR (p_status = 'unreviewed' AND rt.status IS NULL))
  ORDER BY lab.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.ensure_review_threads()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  thread_count integer := 0;
  rec record;
BEGIN
  -- Create threads for dietary_preferences entries that don't have them
  FOR rec IN 
    SELECT dp.id::text as id, dp.user_id
    FROM public.dietary_preferences dp
    LEFT JOIN public.review_threads rt ON (rt.source_table = 'dietary_preferences' AND rt.source_id = dp.id::text)
    WHERE rt.id IS NULL AND dp.deleted_at IS NULL
  LOOP
    INSERT INTO public.review_threads (source_table, source_id, thread_type, status, created_by)
    VALUES ('dietary_preferences', rec.id, 'preference_review', 'unreviewed', rec.user_id);
    thread_count := thread_count + 1;
  END LOOP;

  -- Create threads for log_preference_validation entries that don't have them
  FOR rec IN 
    SELECT lpv.id::text as id, lpv.user_id
    FROM public.log_preference_validation lpv
    LEFT JOIN public.review_threads rt ON (rt.source_table = 'log_preference_validation' AND rt.source_id = lpv.id::text)
    WHERE rt.id IS NULL
  LOOP
    INSERT INTO public.review_threads (source_table, source_id, thread_type, status, created_by)
    VALUES ('log_preference_validation', rec.id, 'preference_validation', 'unreviewed', rec.user_id);
    thread_count := thread_count + 1;
  END LOOP;

  -- Create threads for log_analyzebarcode entries that don't have them
  FOR rec IN 
    SELECT lab.activity_id::text as activity_id, lab.user_id
    FROM public.log_analyzebarcode lab
    LEFT JOIN public.review_threads rt ON (rt.source_table = 'log_analyzebarcode' AND rt.source_id = lab.activity_id::text)
    WHERE rt.id IS NULL
  LOOP
    INSERT INTO public.review_threads (source_table, source_id, thread_type, status, created_by)
    VALUES ('log_analyzebarcode', rec.activity_id, 'barcode_review', 'unreviewed', rec.user_id);
    thread_count := thread_count + 1;
  END LOOP;

  -- Create threads for log_extract entries that don't have them
  FOR rec IN 
    SELECT le.activity_id::text as activity_id, le.user_id
    FROM public.log_extract le
    LEFT JOIN public.review_threads rt ON (rt.source_table = 'log_extract' AND rt.source_id = le.activity_id::text)
    WHERE rt.id IS NULL
  LOOP
    INSERT INTO public.review_threads (source_table, source_id, thread_type, status, created_by)
    VALUES ('log_extract', rec.activity_id, 'extract_review', 'unreviewed', rec.user_id);
    thread_count := thread_count + 1;
  END LOOP;

  RETURN 'Created ' || thread_count || ' missing review threads';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.export_promoted_llm_data(p_tab_type text DEFAULT 'all'::text, p_date_from timestamp with time zone DEFAULT NULL::timestamp with time zone, p_date_to timestamp with time zone DEFAULT NULL::timestamp with time zone, p_limit integer DEFAULT 10000)
 RETURNS TABLE(id text, dietary_preferences text, images jsonb, image_hashes text[], product_info text, flagged_ingredients text, tab_type text, created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_role text;
  is_admin_user boolean;
  is_reviewer_user boolean;
BEGIN
  -- Check user role
  SELECT get_user_role(auth.uid()) INTO user_role;
  SELECT is_admin(auth.uid()) INTO is_admin_user;
  SELECT is_reviewer(auth.uid()) INTO is_reviewer_user;
  
  -- Only allow admin or reviewer users
  IF NOT (is_admin_user OR is_reviewer_user) THEN
    RAISE EXCEPTION 'Access denied. Admin or reviewer role required.';
  END IF;
  
  -- Set default date range to 365 days (changed from 90)
  IF p_date_from IS NULL THEN
    p_date_from := NOW() - INTERVAL '365 days';
  END IF;
  IF p_date_to IS NULL THEN
    p_date_to := NOW();
  END IF;
  
  -- Export Extract LLM data with complete data from review threads
  IF p_tab_type = 'all' OR p_tab_type = 'extract' THEN
    RETURN QUERY
    SELECT 
      REPLACE(rt.source_id, '-', '') as id,
      COALESCE(
        (ed.output_json::jsonb->>'user_preferences')::text,
        COALESCE((ed.output_json::jsonb->'llm_analysis'->>'user_preference_text')::text, '[]')
      ) as dietary_preferences,
      COALESCE(ed.output_json::jsonb->'images', '[]'::jsonb) as images,
      COALESCE(
        (
          SELECT array_agg(img->>'hash')
          FROM jsonb_array_elements(ed.output_json::jsonb->'images') as img
          WHERE img->>'hash' IS NOT NULL AND trim(img->>'hash') != ''
        ),
        ARRAY[]::text[]
      ) as image_hashes,
      COALESCE(
        jsonb_build_object(
          'name', COALESCE((ed.output_json::jsonb->>'name'), ''),
          'brand', COALESCE((ed.output_json::jsonb->>'brand'), ''),
          'ingredients', COALESCE((ed.output_json::jsonb->>'ingredients'), ''),
          'barcode', COALESCE((ed.output_json::jsonb->>'barcode'), ''),
          'matchStatus', COALESCE((ed.output_json::jsonb->>'matchStatus'), 'unknown'),
          'extraction_latency', COALESCE((ed.output_json::jsonb->>'extraction_latency'), '0')
        )::text,
        '{}'
      ) as product_info,
      COALESCE(
        (
          SELECT jsonb_agg(
            jsonb_build_object('name', violation->>'ingredientName')
          )
          FROM jsonb_array_elements(
            COALESCE(ed.output_json::jsonb->'llm_analysis'->'violations', '[]'::jsonb)
          ) as violation
        )::text,
        '[]'
      ) as flagged_ingredients,
      'extract'::text as tab_type,
      le.created_at
    FROM review_threads rt
    JOIN log_extract le ON le.activity_id::text = rt.source_id
    LEFT JOIN LATERAL (
      SELECT * FROM extract_review_list_enhanced(1, 0, 'promoted')
      WHERE subject_id = rt.source_id
      LIMIT 1
    ) ed ON true
    WHERE rt.thread_type IN ('extract_llm', 'extract_review')
      AND rt.status = 'promoted'
      AND le.created_at >= p_date_from
      AND le.created_at <= p_date_to
    ORDER BY le.created_at DESC
    LIMIT p_limit;
  END IF;
  
  -- Export Analyzer LLM (Barcode) data
  IF p_tab_type = 'all' OR p_tab_type = 'analyzer' THEN
    RETURN QUERY
    SELECT 
      REPLACE(lab.activity_id::text, '-', '') as id,
      COALESCE((lab.request_body::jsonb->>'userPreferenceText')::text, '[]') as dietary_preferences,
      COALESCE(
        (
          SELECT jsonb_agg(
            jsonb_build_object(
              'type', 'barcode_image',
              'url', 
              'https://wqidjkpfdrvomfkmefqc.supabase.co/storage/v1/object/public/productimages/' || li.image_file_hash || '.jpg',
              'ocr_text',
              COALESCE(li.image_ocrtext_ios, '')
            )
          )
          FROM log_images li
          WHERE li.client_activity_id = lab.activity_id
            AND li.image_file_hash IS NOT NULL 
            AND trim(li.image_file_hash) != ''
        ),
        '[]'::jsonb
      ) as images,
      COALESCE(
        (
          SELECT array_agg(li.image_file_hash)
          FROM log_images li
          WHERE li.client_activity_id = lab.activity_id
            AND li.image_file_hash IS NOT NULL 
            AND trim(li.image_file_hash) != ''
        ),
        ARRAY[]::text[]
      ) as image_hashes,
      COALESCE(
        jsonb_build_object(
          'name', COALESCE((lab.response_body::jsonb->>'product_name'), ''),
          'brand', COALESCE((lab.response_body::jsonb->>'brand'), ''),
          'ingredients', COALESCE((lab.response_body::jsonb->>'ingredients'), ''),
          'category', COALESCE((lab.response_body::jsonb->>'category'), ''),
          'barcode', COALESCE((lab.response_body::jsonb->>'barcode'), '')
        )::text,
        '{}'
      ) as product_info,
      COALESCE(
        (
          SELECT jsonb_agg(
            jsonb_build_object('name', violation->>'ingredientName')
          )
          FROM jsonb_array_elements(
            CASE 
              WHEN lab.response_body::jsonb ? 'violations' 
              THEN lab.response_body::jsonb->'violations'
              ELSE '[]'::jsonb
            END
          ) as violation
        )::text,
        '[]'
      ) as flagged_ingredients,
      'analyzer'::text as tab_type,
      lab.created_at
    FROM review_threads rt
    JOIN log_analyzebarcode lab ON rt.source_id = lab.activity_id::text
    WHERE rt.thread_type = 'analyze_llm'
      AND rt.status = 'promoted'
      AND lab.created_at >= p_date_from
      AND lab.created_at <= p_date_to
    ORDER BY lab.created_at DESC
    LIMIT p_limit;
  END IF;
  
  -- Export Preference Validation data
  IF p_tab_type = 'all' OR p_tab_type = 'preferences' THEN
    RETURN QUERY
    SELECT 
      dp.id::text as id,
      COALESCE(dp.text, '[]') as dietary_preferences,
      '[]'::jsonb as images,
      ARRAY[]::text[] as image_hashes,
      COALESCE(
        jsonb_build_object(
          'name', 'Dietary Preference Validation',
          'ingredients', COALESCE(dp.annotated_text, ''),
          'confidence_score', '0'
        )::text,
        '{}'
      ) as product_info,
      '[]'::text as flagged_ingredients,
      'preferences'::text as tab_type,
      dp.created_at
    FROM review_threads rt
    JOIN dietary_preferences dp ON rt.source_id = dp.id::text
    WHERE rt.thread_type = 'preference_review'
      AND rt.status = 'promoted'
      AND dp.created_at >= p_date_from
      AND dp.created_at <= p_date_to
    ORDER BY dp.created_at DESC
    LIMIT p_limit;
  END IF;
  
  RETURN;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.extract_review_count()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM public.log_extract
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.extract_review_list(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_status text DEFAULT 'all'::text)
 RETURNS TABLE(thread_id uuid, subject_id text, input_json text, output_json text, status text, latency_ms numeric, created_at timestamp with time zone, reviewer_ids uuid[], comment_count bigint, reviewers jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    rt.id AS thread_id,
    rt.source_id AS subject_id,
    jsonb_build_object(
      'images', to_jsonb(le.images),
      'barcode', le.barcode,
      'userPreferenceText', lab.request_body->>'userPreferenceText'
    )::text AS input_json,
    jsonb_build_object(
      'name', le.name,
      'brand', le.brand,
      'barcode', le.barcode,
      'ingredients', le.ingredients,
      'images', COALESCE(
        (SELECT jsonb_agg(
          jsonb_build_object(
            'hash', li_img.image_file_hash,
            'ocr_text', li_img.image_ocrtext_ios,
            'barcode', li_img.barcode_ios
          )
        )
        FROM public.log_images li_img
        WHERE li_img.activity_id = le.activity_id), 
        to_jsonb(le.images)
      ),
      'matchStatus', CASE 
        WHEN lab.response_body IS NOT NULL THEN 'unmatched'
        ELSE 'matched'
      END,
      'violations', COALESCE(lab.response_body::jsonb, '[]'::jsonb),
      'userPreferenceText', lab.request_body->>'userPreferenceText',
      'extraction_latency', COALESCE(EXTRACT(EPOCH FROM (le.end_time - le.start_time)) * 1000, 0)
    )::text AS output_json,
    COALESCE(rt.status, 'unreviewed') AS status,
    COALESCE(EXTRACT(EPOCH FROM (le.end_time - le.start_time)) * 1000, 0)::numeric AS latency_ms,
    le.created_at,
    COALESCE(
      (SELECT array_agg(ra.reviewer_id)
       FROM public.review_assignments ra
       WHERE ra.thread_id = rt.id), 
      ARRAY[]::uuid[]
    ) AS reviewer_ids,
    COALESCE(
      (SELECT COUNT(*)
       FROM public.review_comments rc
       WHERE rc.thread_id = rt.id), 
      0
    )::bigint AS comment_count,
    COALESCE(
      (SELECT jsonb_agg(
        jsonb_build_object(
          'id', ra.reviewer_id,
          'email', 'reviewer@example.com',
          'assigned_at', ra.assigned_at
        )
      )
      FROM public.review_assignments ra
      WHERE ra.thread_id = rt.id), 
      '[]'::jsonb
    ) AS reviewers
  FROM public.review_threads rt
  INNER JOIN public.log_extract le ON le.activity_id::text = rt.source_id
  LEFT JOIN public.log_analyzebarcode lab ON lab.request_body->>'barcode' = le.barcode
  WHERE rt.source_table = 'log_extract'
  AND (p_status = 'all' OR rt.status = p_status OR (p_status = 'unreviewed' AND rt.status IS NULL))
  ORDER BY le.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.extract_review_list_enhanced(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_status text DEFAULT 'all'::text)
 RETURNS TABLE(thread_id uuid, subject_id text, input_json text, output_json text, status text, latency_ms numeric, created_at timestamp with time zone, reviewer_ids uuid[], comment_count bigint, reviewers jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  WITH extract_with_preferences AS (
    SELECT 
      le.activity_id,
      le.client_activity_id,
      le.barcode,
      le.name,
      le.brand,
      le.ingredients,
      le.images,
      le.created_at as extract_created_at,
      le.start_time,
      le.end_time,
      -- Get the most recent LLM analysis for this barcode with user preferences
      lab.request_body->>'userPreferenceText' as user_preference_text,
      lab.response_body::jsonb as llm_violations,
      lab.created_at as analysis_created_at,
      ROW_NUMBER() OVER (
        PARTITION BY le.barcode 
        ORDER BY lab.created_at DESC
      ) as rn
    FROM public.log_extract le
    LEFT JOIN public.log_analyzebarcode lab ON (
      lab.request_body->>'barcode' = le.barcode
      AND lab.request_body->>'userPreferenceText' IS NOT NULL
      AND lab.request_body->>'userPreferenceText' != 'None'
      AND lab.request_body->>'userPreferenceText' != ''
    )
    WHERE le.barcode IS NOT NULL
  ),
  latest_analysis AS (
    SELECT * FROM extract_with_preferences WHERE rn = 1
  ),
  review_data AS (
    SELECT 
      la.activity_id,
      la.client_activity_id,
      la.barcode,
      la.name,
      la.brand,
      la.ingredients,
      la.images,
      la.extract_created_at,
      la.start_time,
      la.end_time,
      la.user_preference_text,
      la.llm_violations,
      la.analysis_created_at,
      rt.id as review_thread_id,
      rt.status as review_status,
      (
        SELECT array_agg(ra.reviewer_id)
        FROM public.review_assignments ra
        WHERE ra.thread_id = rt.id
      ) as assigned_reviewer_ids,
      (
        SELECT jsonb_agg(
          jsonb_build_object(
            'id', ra.reviewer_id,
            'email', 'reviewer@example.com',
            'assigned_at', ra.assigned_at
          )
        )
        FROM public.review_assignments ra
        WHERE ra.thread_id = rt.id
      ) as reviewer_info,
      (
        SELECT COUNT(*)
        FROM public.review_comments rc
        WHERE rc.thread_id = rt.id
      ) as thread_comment_count
    FROM latest_analysis la
    LEFT JOIN public.review_threads rt ON (
      rt.source_table = 'log_extract' 
      AND rt.source_id = la.activity_id::text
    )
  )
  SELECT 
    rd.review_thread_id AS thread_id,
    rd.activity_id::text AS subject_id,
    jsonb_build_object(
      'images', to_jsonb(rd.images),
      'barcode', rd.barcode,
      'product_name', rd.name,
      'brand', rd.brand
    )::text AS input_json,
    jsonb_build_object(
      'name', rd.name,
      'brand', rd.brand,
      'barcode', rd.barcode,
      'ingredients', rd.ingredients,
      'images', COALESCE(
        (SELECT jsonb_agg(
          jsonb_build_object(
            'hash', li_img.image_file_hash,
            'ocr_text', li_img.image_ocrtext_ios,
            'barcode', li_img.barcode_ios
          )
        )
        FROM public.log_images li_img
        WHERE li_img.activity_id = rd.activity_id), 
        to_jsonb(rd.images)
      ),
      'user_preferences', rd.user_preference_text,
      'llm_analysis', jsonb_build_object(
        'violations', COALESCE(rd.llm_violations, '[]'::jsonb),
        'user_preference_text', rd.user_preference_text,
        'analysis_created_at', rd.analysis_created_at,
        'has_violations', CASE 
          WHEN rd.llm_violations IS NOT NULL 
               AND jsonb_typeof(rd.llm_violations) = 'array' 
               AND jsonb_array_length(rd.llm_violations) > 0 
          THEN true 
          ELSE false 
        END,
        'violation_count', CASE 
          WHEN rd.llm_violations IS NOT NULL 
               AND jsonb_typeof(rd.llm_violations) = 'array' 
          THEN jsonb_array_length(rd.llm_violations)
          ELSE 0 
        END
      ),
      'matchStatus', CASE 
        WHEN rd.llm_violations IS NOT NULL 
             AND jsonb_typeof(rd.llm_violations) = 'array' 
             AND jsonb_array_length(rd.llm_violations) > 0 
        THEN 'unmatched' 
        ELSE 'matched' 
      END,
      'extraction_latency', COALESCE(EXTRACT(EPOCH FROM (rd.end_time - rd.start_time)) * 1000, 0)
    )::text AS output_json,
    COALESCE(rd.review_status, 'unreviewed') AS status,
    COALESCE(EXTRACT(EPOCH FROM (rd.end_time - rd.start_time)) * 1000, 0)::numeric AS latency_ms,
    rd.extract_created_at AS created_at,
    COALESCE(rd.assigned_reviewer_ids, ARRAY[]::uuid[]) AS reviewer_ids,
    COALESCE(rd.thread_comment_count, 0)::bigint AS comment_count,
    COALESCE(rd.reviewer_info, '[]'::jsonb) AS reviewers
  FROM review_data rd
  WHERE rd.review_thread_id IS NOT NULL
  AND (p_status = 'all' OR rd.review_status = p_status OR (p_status = 'unreviewed' AND rd.review_status IS NULL))
  ORDER BY rd.extract_created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_available_reviewers()
 RETURNS TABLE(reviewer_id uuid, reviewer_name text, assigned_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF NOT is_admin(auth.uid()) THEN
        RAISE EXCEPTION 'Only admins can view reviewers';
    END IF;
    
    RETURN QUERY
    SELECT 
        ur.user_id as reviewer_id,
        au.email as reviewer_name,
        COUNT(ra.id) as assigned_count
    FROM public.user_roles ur
    JOIN auth.users au ON au.id = ur.user_id
    LEFT JOIN public.review_assignments ra ON ra.reviewer_id = ur.user_id
    WHERE ur.role IN ('reviewer', 'admin')
    GROUP BY ur.user_id, au.email
    ORDER BY assigned_count ASC, au.email;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_check_history(search_query text DEFAULT NULL::text)
 RETURNS TABLE(created_at timestamp with time zone, client_activity_id uuid, barcode text, name text, brand text, ingredients json, images json, ingredient_recommendations json, rating integer, favorited boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        sub.created_at,
        sub.client_activity_id,
        sub.barcode,
        sub.name,
        sub.brand,
        sub.ingredients,
        sub.images,
        sub.ingredient_recommendations,
        sub.rating,
        sub.favorited
    FROM (
        SELECT DISTINCT ON (barcode, name, brand)
            la.created_at,
            la.client_activity_id,
            COALESCE(li.barcode, le.barcode) AS barcode,
            COALESCE(li.name, le.name) AS name,
            COALESCE(li.brand, le.brand) AS brand,
            COALESCE(li.ingredients, le.ingredients) AS ingredients,
            COALESCE(
                li.images,
                (SELECT json_agg(json_build_object('imageFileHash', text_val)) FROM unnest(le.images) AS dt(text_val))
            ) AS images,
            la.response_body AS ingredient_recommendations,
            COALESCE(lf.rating, 0) AS rating,
            EXISTS(
                SELECT 1
                FROM public.user_list_items uli
                WHERE
                    uli.list_item_id = la.client_activity_id
                    AND uli.list_id = '00000000-0000-0000-0000-000000000000'::uuid
            ) AS favorited
        FROM
            public.log_analyzebarcode la
        LEFT JOIN public.log_inventory li 
            ON la.client_activity_id = li.client_activity_id 
        LEFT JOIN public.log_extract le 
            ON la.client_activity_id = le.client_activity_id 
        LEFT JOIN public.log_feedback lf
            ON la.client_activity_id = lf.client_activity_id
        WHERE
            la.created_at > '2024-03-15'::date
            AND
            (
                li.client_activity_id IS NOT NULL
                OR
                le.client_activity_id IS NOT NULL
            )
            AND
            (
                search_query IS NULL
                OR
                to_tsvector('english', COALESCE(li.name, le.name) || ' ' || COALESCE(li.brand, le.brand) || ' ' || COALESCE(li.ingredients::text, le.ingredients::text)) @@ plainto_tsquery('english', search_query)
                OR
                COALESCE(li.name, le.name) ILIKE '%' || search_query || '%'
                OR
                COALESCE(li.brand, le.brand) ILIKE '%' || search_query || '%'
                OR
                COALESCE(li.ingredients::text, le.ingredients::text) ILIKE '%' || search_query || '%'
            )
        ORDER BY
            barcode, name, brand, la.created_at DESC
    ) AS sub
    ORDER BY
        sub.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_dashboard_permissions(user_uuid uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    user_role TEXT;
    permissions JSON;
BEGIN
    user_role := get_user_role(user_uuid);
    
    CASE user_role
        WHEN 'admin' THEN
            permissions := json_build_object(
                'dashboard', true,
                'products', true,
                'review', true,
                'analytics', true,
                'user_management', true
            );
        WHEN 'reviewer' THEN
            permissions := json_build_object(
                'dashboard', true,
                'products', true,
                'review', true,
                'analytics', false,
                'user_management', false
            );
        ELSE
            permissions := json_build_object(
                'dashboard', false,
                'products', false,
                'review', false,
                'analytics', false,
                'user_management', false
            );
    END CASE;
    
    RETURN permissions;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_dashboard_totals()
 RETURNS TABLE(total_scans bigint, total_extractions bigint, total_feedback bigint, total_list_items bigint, total_history_items bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    (SELECT COUNT(*) FROM log_analyzebarcode) as total_scans,
    (SELECT COUNT(*) FROM log_extract) as total_extractions,
    (SELECT COUNT(*) FROM log_feedback) as total_feedback,
    (SELECT COUNT(*) FROM user_list_items) as total_list_items,
    (SELECT COUNT(*) FROM log_images) as total_history_items;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_distinct_user_count()
 RETURNS bigint
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN (SELECT COUNT(DISTINCT id) FROM auth.users);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_list_items(input_list_id uuid, search_query text DEFAULT NULL::text)
 RETURNS TABLE(created_at timestamp with time zone, list_id uuid, list_item_id uuid, barcode text, name text, brand text, ingredients json, images json)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        uli.created_at,
        uli.list_id,
        uli.list_item_id,
        COALESCE(li.barcode, le.barcode) AS barcode,
        COALESCE(li.name, le.name) AS name,
        COALESCE(li.brand, le.brand) AS brand,
        COALESCE(li.ingredients, le.ingredients::json) AS ingredients,
        COALESCE(
            li.images,
            (SELECT json_agg(json_build_object('imageFileHash', text_val)) FROM unnest(le.images) AS dt(text_val))
        ) AS images
    FROM
        public.user_list_items uli
        LEFT JOIN public.log_inventory li ON uli.list_item_id = li.client_activity_id
        LEFT JOIN public.log_extract le ON uli.list_item_id = le.client_activity_id
    WHERE
        uli.list_id = input_list_id
        AND
        (
            li.client_activity_id IS NOT NULL
            OR
            le.client_activity_id IS NOT NULL
        )
        AND
        (
            search_query IS NULL
            OR
            to_tsvector('english', COALESCE(li.name, le.name) || ' ' || COALESCE(li.brand, le.brand) || ' ' || COALESCE(li.ingredients::text, le.ingredients::text)) @@ plainto_tsquery('english', search_query)
            OR
            COALESCE(li.name, le.name) ILIKE '%' || search_query || '%'
            OR
            COALESCE(li.brand, le.brand) ILIKE '%' || search_query || '%'
            OR
            COALESCE(li.ingredients::text, le.ingredients::text) ILIKE '%' || search_query || '%'
        )
    ORDER BY
        uli.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_performance_metrics(days_back integer DEFAULT 30)
 RETURNS TABLE(avg_latency numeric, success_rate numeric, total_requests bigint, error_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  WITH performance_data AS (
    SELECT 
      ROUND(EXTRACT(EPOCH FROM (end_time - start_time)) * 1000) as latency_ms,
      response_status
    FROM log_analyzebarcode 
    WHERE created_at > CURRENT_DATE - (days_back || ' days')::interval
      AND start_time IS NOT NULL 
      AND end_time IS NOT NULL
  )
  SELECT 
    ROUND(AVG(latency_ms), 2) as avg_latency,
    ROUND((COUNT(*) FILTER (WHERE response_status = 200)::numeric / COUNT(*)) * 100, 2) as success_rate,
    COUNT(*) as total_requests,
    COUNT(*) FILTER (WHERE response_status != 200) as error_count
  FROM performance_data;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_popular_products(limit_count integer DEFAULT 10)
 RETURNS TABLE(product_name text, scan_count bigint, category text, avg_latency numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(response_body->>'name', request_body->>'text', 'Unknown Product') as product_name,
    COUNT(*) as scan_count,
    COALESCE(response_body->>'category', 'Unknown') as category,
    ROUND(AVG(EXTRACT(EPOCH FROM (end_time - start_time)) * 1000), 2) as avg_latency
  FROM log_analyzebarcode
  WHERE start_time IS NOT NULL AND end_time IS NOT NULL
  GROUP BY response_body->>'name', request_body->>'text', response_body->>'category'
  ORDER BY scan_count DESC
  LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_product_brands()
 RETURNS TABLE(brand text, product_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        li.brand,
        COUNT(*) as product_count
    FROM log_inventory li
    WHERE li.brand IS NOT NULL
    GROUP BY li.brand
    ORDER BY product_count DESC, li.brand;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_product_data_sources()
 RETURNS TABLE(data_source text, product_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        li.data_source,
        COUNT(*) as product_count
    FROM log_inventory li
    GROUP BY li.data_source
    ORDER BY product_count DESC, li.data_source;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_products_list(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_search text DEFAULT NULL::text, p_brand text DEFAULT NULL::text, p_data_source text DEFAULT NULL::text)
 RETURNS TABLE(id uuid, name text, brand text, barcode text, data_source text, ingredients json, images json, created_at timestamp with time zone, user_id uuid, total_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    total_products bigint;
BEGIN
    -- Get total count for pagination
    SELECT COUNT(*) INTO total_products
    FROM log_inventory li
    WHERE (p_search IS NULL OR 
           li.name ILIKE '%' || p_search || '%' OR 
           li.brand ILIKE '%' || p_search || '%' OR
           li.barcode ILIKE '%' || p_search || '%')
    AND (p_brand IS NULL OR li.brand ILIKE '%' || p_brand || '%')
    AND (p_data_source IS NULL OR li.data_source = p_data_source);

    -- Return paginated results
    RETURN QUERY
    SELECT 
        li.user_id as id,
        li.name,
        li.brand,
        li.barcode,
        li.data_source,
        li.ingredients,
        li.images,
        li.created_at,
        li.user_id,
        total_products
    FROM log_inventory li
    WHERE (p_search IS NULL OR 
           li.name ILIKE '%' || p_search || '%' OR 
           li.brand ILIKE '%' || p_search || '%' OR
           li.barcode ILIKE '%' || p_search || '%')
    AND (p_brand IS NULL OR li.brand ILIKE '%' || p_brand || '%')
    AND (p_data_source IS NULL OR li.data_source = p_data_source)
    ORDER BY li.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_products_stats()
 RETURNS TABLE(total_products bigint, unique_brands bigint, unique_data_sources bigint, products_with_images bigint, products_with_ingredients bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_products,
        COUNT(DISTINCT brand) FILTER (WHERE brand IS NOT NULL) as unique_brands,
        COUNT(DISTINCT data_source) as unique_data_sources,
        COUNT(*) FILTER (WHERE images IS NOT NULL AND jsonb_array_length(images::jsonb) > 0) as products_with_images,
        COUNT(*) FILTER (WHERE ingredients IS NOT NULL AND jsonb_array_length(ingredients::jsonb) > 0) as products_with_ingredients
    FROM log_inventory;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_review_data(p_thread_type text, p_status text DEFAULT NULL::text, p_limit integer DEFAULT 100)
 RETURNS TABLE(thread_id uuid, source_id uuid, input_json text, output_json text, status text, latency_ms integer, created_at timestamp with time zone, reviewer_name text, reviewer_id uuid, comment_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF p_thread_type = 'preference_validation' THEN
        RETURN QUERY
        SELECT 
            rt.id as thread_id,
            lpv.id as source_id,
            lpv.input_text as input_json,
            lpv.output_interpretation::text as output_json,
            COALESCE(rt.status, 'unreviewed') as status,
            lpv.latency_ms,
            lpv.created_at,
            au.email as reviewer_name,
            ra.reviewer_id,
            COALESCE(comment_counts.cnt, 0) as comment_count
        FROM public.log_preference_validation lpv
        LEFT JOIN public.review_threads rt ON rt.source_id = lpv.id AND rt.source_table = 'log_preference_validation'
        LEFT JOIN public.review_assignments ra ON ra.thread_id = rt.id
        LEFT JOIN auth.users au ON au.id = ra.reviewer_id
        LEFT JOIN LATERAL (
            SELECT COUNT(*) as cnt 
            FROM public.review_comments rc 
            WHERE rc.thread_id = rt.id
        ) comment_counts ON true
        WHERE (p_status IS NULL OR rt.status = p_status OR (p_status = 'unreviewed' AND rt.status IS NULL))
        ORDER BY lpv.created_at DESC
        LIMIT p_limit;
        
    ELSIF p_thread_type = 'analyze_llm' THEN
        RETURN QUERY
        SELECT 
            rt.id as thread_id,
            la.activity_id as source_id,
            COALESCE(la.request_body->>'text', li.barcode, 'N/A') as input_json,
            COALESCE(la.response_body::text, COALESCE(li.name, '') || ' - ' || COALESCE(li.brand, '')) as output_json,
            COALESCE(rt.status, 'unreviewed') as status,
            ROUND(EXTRACT(EPOCH FROM (la.end_time - la.start_time)) * 1000)::integer as latency_ms,
            la.created_at,
            au.email as reviewer_name,
            ra.reviewer_id,
            COALESCE(comment_counts.cnt, 0) as comment_count
        FROM public.log_analyzebarcode la
        LEFT JOIN public.log_inventory li ON li.client_activity_id = la.client_activity_id
        LEFT JOIN public.review_threads rt ON rt.source_id = la.activity_id AND rt.source_table = 'log_analyzebarcode'
        LEFT JOIN public.review_assignments ra ON ra.thread_id = rt.id
        LEFT JOIN auth.users au ON au.id = ra.reviewer_id
        LEFT JOIN LATERAL (
            SELECT COUNT(*) as cnt 
            FROM public.review_comments rc 
            WHERE rc.thread_id = rt.id
        ) comment_counts ON true
        WHERE (p_status IS NULL OR rt.status = p_status OR (p_status = 'unreviewed' AND rt.status IS NULL))
        ORDER BY la.created_at DESC
        LIMIT p_limit;
        
    ELSIF p_thread_type = 'extract_llm' THEN
        RETURN QUERY
        SELECT 
            rt.id as thread_id,
            le.activity_id as source_id,
            COALESCE(le.name, 'Photo extraction') as input_json,
            jsonb_build_object(
                'ingredients', le.ingredients,
                'brand', le.brand,
                'name', le.name
            )::text as output_json,
            COALESCE(rt.status, 'unreviewed') as status,
            ROUND(EXTRACT(EPOCH FROM (le.end_time - le.start_time)) * 1000)::integer as latency_ms,
            le.created_at,
            au.email as reviewer_name,
            ra.reviewer_id,
            COALESCE(comment_counts.cnt, 0) as comment_count
        FROM public.log_extract le
        LEFT JOIN public.review_threads rt ON rt.source_id = le.activity_id AND rt.source_table = 'log_extract'
        LEFT JOIN public.review_assignments ra ON ra.thread_id = rt.id
        LEFT JOIN auth.users au ON au.id = ra.reviewer_id
        LEFT JOIN LATERAL (
            SELECT COUNT(*) as cnt 
            FROM public.review_comments rc 
            WHERE rc.thread_id = rt.id
        ) comment_counts ON true
        WHERE (p_status IS NULL OR rt.status = p_status OR (p_status = 'unreviewed' AND rt.status IS NULL))
        ORDER BY le.created_at DESC
        LIMIT p_limit;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_reviewers_list()
 RETURNS TABLE(id uuid, email character varying, created_at timestamp with time zone, role character varying, assigned_by uuid, assigned_at timestamp with time zone, is_active boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    u.id,
    u.email::character varying,
    u.created_at,
    ur.role::character varying,
    ur.assigned_by,
    ur.assigned_at,
    COALESCE(ur.is_active, true) as is_active
  FROM auth.users u
  LEFT JOIN public.user_roles ur ON ur.user_id = u.id
  WHERE ur.is_active IS NULL OR ur.is_active = true
  ORDER BY u.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_scan_activity_data(days_back integer DEFAULT 30)
 RETURNS TABLE(date date, scans bigint, extractions bigint, success_rate numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  WITH daily_data AS (
    SELECT 
      DATE(created_at) as activity_date,
      COUNT(*) FILTER (WHERE table_name = 'log_analyzebarcode') as scan_count,
      COUNT(*) FILTER (WHERE table_name = 'log_extract') as extract_count,
      COUNT(*) FILTER (WHERE table_name = 'log_analyzebarcode' AND response_status = 200) as success_count,
      COUNT(*) FILTER (WHERE table_name = 'log_analyzebarcode') as total_count
    FROM (
      SELECT created_at, 'log_analyzebarcode' as table_name, response_status FROM log_analyzebarcode
      UNION ALL
      SELECT created_at, 'log_extract' as table_name, 200 as response_status FROM log_extract
    ) combined
    WHERE created_at > CURRENT_DATE - (days_back || ' days')::interval
    GROUP BY DATE(created_at)
  )
  SELECT 
    activity_date,
    scan_count,
    extract_count,
    CASE 
      WHEN total_count > 0 THEN ROUND((success_count::numeric / total_count) * 100, 2)
      ELSE 0 
    END as success_rate
  FROM daily_data
  ORDER BY activity_date;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_emails(user_ids uuid[])
 RETURNS TABLE(id uuid, email text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT u.id, u.email::text
  FROM auth.users u
  WHERE u.id = ANY(user_ids);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_engagement_data(days_back integer DEFAULT 30)
 RETURNS TABLE(date date, daily_users bigint, weekly_users bigint, monthly_users bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  WITH user_activity AS (
    SELECT 
      DATE(created_at) as activity_date,
      user_id
    FROM (
      SELECT created_at, user_id FROM log_analyzebarcode
      UNION ALL
      SELECT created_at, user_id FROM log_extract
      UNION ALL
      SELECT created_at, user_id FROM log_feedback
    ) combined
    WHERE created_at > CURRENT_DATE - (days_back || ' days')::interval
  )
  SELECT 
    activity_date,
    COUNT(DISTINCT user_id) as daily_users,
    COUNT(DISTINCT user_id) FILTER (WHERE activity_date >= CURRENT_DATE - INTERVAL '7 days') as weekly_users,
    COUNT(DISTINCT user_id) FILTER (WHERE activity_date >= CURRENT_DATE - INTERVAL '30 days') as monthly_users
  FROM user_activity
  GROUP BY activity_date
  ORDER BY activity_date;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_role(user_uuid uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    user_role TEXT;
BEGIN
    SELECT role INTO user_role
    FROM user_roles
    WHERE user_id = user_uuid;
    
    RETURN COALESCE(user_role, 'none');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_users_with_roles()
 RETURNS TABLE(id uuid, email text, created_at timestamp with time zone, role text, assigned_by uuid, assigned_at timestamp with time zone, is_active boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Check if the current user is an admin
  IF NOT EXISTS (
    SELECT 1 FROM public.user_roles ur
    WHERE ur.user_id = auth.uid() 
    AND ur.role = 'admin' 
    AND ur.is_active = true
  ) THEN
    RAISE EXCEPTION 'Access denied: Admin role required';
  END IF;

  RETURN QUERY
  SELECT 
    u.id,
    u.email::text,  -- Cast email to text to match return type
    u.created_at,
    ur.role::text,  -- Ensure role is cast to text
    ur.assigned_by,
    ur.assigned_at,
    ur.is_active
  FROM auth.users u
  LEFT JOIN public.user_roles ur ON ur.user_id = u.id
  WHERE ur.is_active = true OR ur.is_active IS NULL
  ORDER BY u.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_role(user_uuid uuid, required_role text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN get_user_role(user_uuid) = required_role;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_admin(user_uuid uuid DEFAULT auth.uid())
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_roles 
    WHERE user_roles.user_id = is_admin.user_uuid 
    AND user_roles.role = 'admin' 
    AND user_roles.is_active = true
    AND (user_roles.expires_at IS NULL OR user_roles.expires_at > NOW())
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_reviewer(user_uuid uuid DEFAULT auth.uid())
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_roles 
    WHERE user_roles.user_id = is_reviewer.user_uuid 
    AND user_roles.role IN ('admin', 'reviewer') 
    AND user_roles.is_active = true
    AND (user_roles.expires_at IS NULL OR user_roles.expires_at > NOW())
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.preferences_review_count()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM public.dietary_preferences dp
    WHERE dp.deleted_at IS NULL
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.preferences_review_list(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_status text DEFAULT 'all'::text)
 RETURNS TABLE(thread_id uuid, subject_id text, input_json text, output_json text, status text, latency_ms numeric, created_at timestamp with time zone, reviewer_ids uuid[], comment_count bigint, reviewers jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    rt.id AS thread_id,
    rt.source_id AS subject_id,
    jsonb_build_object(
      'input_text', dp.text,
      'user_id', dp.user_id,
      'preference_id', dp.id
    )::text AS input_json,
    jsonb_build_object(
      'annotated_text', COALESCE(lpv.output_interpretation->>'annotated_text', dp.text),
      'agent_name', COALESCE(lpv.output_interpretation->>'agent_name', 'preferenceValidatorAgent'),
      'processing_type', COALESCE(lpv.output_interpretation->>'processing_type', 'dietary_preference_entry'),
      'confidence_score', COALESCE((lpv.output_interpretation->>'confidence_score')::numeric, 0.8),
      'extracted_ingredients', COALESCE(lpv.output_interpretation->'extracted_ingredients', '[]'::jsonb)
    )::text AS output_json,
    COALESCE(rt.status, 'unreviewed') AS status,
    COALESCE(lpv.latency_ms, 0)::numeric AS latency_ms,
    dp.created_at,
    COALESCE(
      (SELECT array_agg(ra.reviewer_id)
       FROM public.review_assignments ra
       WHERE ra.thread_id = rt.id), 
      ARRAY[]::uuid[]
    ) AS reviewer_ids,
    COALESCE(
      (SELECT COUNT(*)
       FROM public.review_comments rc
       WHERE rc.thread_id = rt.id), 
      0
    )::bigint AS comment_count,
    COALESCE(
      (SELECT jsonb_agg(
        jsonb_build_object(
          'id', ra.reviewer_id,
          'email', 'reviewer@example.com',
          'assigned_at', ra.assigned_at
        )
      )
      FROM public.review_assignments ra
      WHERE ra.thread_id = rt.id), 
      '[]'::jsonb
    ) AS reviewers
  FROM public.review_threads rt
  INNER JOIN public.dietary_preferences dp ON dp.id::text = rt.source_id
  LEFT JOIN public.log_preference_validation lpv ON lpv.input_text = dp.text
  WHERE rt.source_table = 'dietary_preferences'
  AND dp.deleted_at IS NULL
  AND (p_status = 'all' OR rt.status = p_status OR (p_status = 'unreviewed' AND rt.status IS NULL))
  ORDER BY dp.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.review_assign(p_thread_id uuid, p_reviewer_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Only admins can assign
    IF NOT is_admin(auth.uid()) THEN
        RAISE EXCEPTION 'Only admins can assign reviewers';
    END IF;
    
    -- Insert assignment
    INSERT INTO public.review_assignments (thread_id, reviewer_id, assigned_by)
    VALUES (p_thread_id, p_reviewer_id, auth.uid())
    ON CONFLICT (thread_id, reviewer_id) DO NOTHING;
    
    -- Add comment about assignment
    PERFORM review_comment_add(
        p_thread_id,
        'Assigned to reviewer',
        'assignment',
        jsonb_build_object('reviewer_id', p_reviewer_id)
    );
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.review_comment_add(p_thread_id uuid, p_comment text, p_action text DEFAULT 'comment'::text, p_metadata jsonb DEFAULT NULL::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_comment_id UUID;
BEGIN
    INSERT INTO public.review_comments (thread_id, user_id, comment, action, metadata)
    VALUES (p_thread_id, auth.uid(), p_comment, p_action, p_metadata)
    RETURNING id INTO v_comment_id;
    
    -- Update thread updated_at
    UPDATE public.review_threads
    SET updated_at = now()
    WHERE id = p_thread_id;
    
    RETURN v_comment_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.review_open_or_get_thread(p_source_table text, p_source_id uuid, p_thread_type text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_thread_id UUID;
BEGIN
    -- Check if thread exists
    SELECT id INTO v_thread_id
    FROM public.review_threads
    WHERE source_table = p_source_table
    AND source_id = p_source_id;
    
    -- Create if doesn't exist
    IF v_thread_id IS NULL THEN
        INSERT INTO public.review_threads (source_table, source_id, thread_type, created_by)
        VALUES (p_source_table, p_source_id, p_thread_type, auth.uid())
        RETURNING id INTO v_thread_id;
    END IF;
    
    RETURN v_thread_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.review_open_or_get_thread(p_source_table text, p_source_id uuid, p_thread_type text, p_user_id uuid DEFAULT NULL::uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_thread_id uuid;
BEGIN
  -- Try to find existing thread
  SELECT id INTO v_thread_id
  FROM public.review_threads
  WHERE source_table = p_source_table
    AND source_id = p_source_id
  LIMIT 1;
  
  -- If no thread exists, create one
  IF v_thread_id IS NULL THEN
    INSERT INTO public.review_threads (
      source_table,
      source_id,
      thread_type,
      status,
      created_by
    )
    VALUES (
      p_source_table,
      p_source_id,
      p_thread_type,
      'unreviewed',
      p_user_id
    )
    RETURNING id INTO v_thread_id;
  END IF;
  
  RETURN v_thread_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_barcode_review_list()
 RETURNS TABLE(thread_id uuid, subject_id uuid, output_interpretation text, status text, latency_ms integer, created_at timestamp with time zone, reviewer_ids uuid[], comment_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        COALESCE(li.client_activity_id, le.client_activity_id, gen_random_uuid()) as thread_id,
        li.user_id as subject_id,
        json_build_object(
            'product_name', COALESCE(li.name, le.name, 'Unknown Product'),
            'barcode', COALESCE(li.barcode, le.barcode, 'N/A'),
            'category', COALESCE(li.data_source, 'Unknown'),
            'brand', COALESCE(li.brand, le.brand, ''),
            'ingredients', COALESCE(li.ingredients, le.ingredients)
        )::text as output_interpretation,
        CASE
            WHEN li.name IS NOT NULL OR le.name IS NOT NULL THEN 'resolved'
            ELSE 'open'
        END as status,
        COALESCE(
            ROUND(EXTRACT(EPOCH FROM (li.end_time - li.start_time)) * 1000)::integer,
            300
        ) as latency_ms,
        COALESCE(li.created_at, le.created_at) as created_at,
        ARRAY[]::uuid[] as reviewer_ids,
        (SELECT COUNT(*) FROM log_feedback lf WHERE lf.client_activity_id = COALESCE(li.client_activity_id, le.client_activity_id))::bigint as comment_count
    FROM log_inventory li
    FULL OUTER JOIN log_extract le ON li.client_activity_id = le.client_activity_id
    WHERE COALESCE(li.created_at, le.created_at) > NOW() - INTERVAL '30 days'
      AND (li.client_activity_id IS NOT NULL OR le.client_activity_id IS NOT NULL)
    ORDER BY COALESCE(li.created_at, le.created_at) DESC
    LIMIT 100;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_preferences_review_list()
 RETURNS TABLE(thread_id uuid, subject_id uuid, input_json text, output_json text, status text, latency_ms integer, created_at timestamp with time zone, reviewer_ids uuid[], comment_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        COALESCE(dp.id::uuid, gen_random_uuid()) as thread_id,
        dp.user_id as subject_id,
        COALESCE(dp.text, dp.annotated_text, '') as input_json,
        COALESCE(dp.annotated_text, dp.text, '') as output_json,
        CASE
            WHEN dp.annotated_text IS NOT NULL THEN 'resolved'
            ELSE 'open'
        END as status,
        0 as latency_ms,
        dp.created_at,
        ARRAY[]::uuid[] as reviewer_ids,
        0::bigint as comment_count
    FROM dietary_preferences dp
    WHERE dp.created_at > NOW() - INTERVAL '30 days'
      AND dp.deleted_at IS NULL
    ORDER BY dp.created_at DESC
    LIMIT 100;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

create policy "Admins can view all access logs"
on "public"."dashboard_access_logs"
as permissive
for select
to public
using (is_admin(auth.uid()));


create policy "Users can view their own access logs"
on "public"."dashboard_access_logs"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "user_update_own_dietary_preferences"
on "public"."dietary_preferences"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "reviewers_can_select_all_log_analyzebarcode"
on "public"."log_analyzebarcode"
as permissive
for select
to public
using (is_reviewer(auth.uid()));


create policy "user_update_own_log_infer"
on "public"."log_analyzebarcode"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Insert for authenticated users"
on "public"."log_extract"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Select for all authenticated users"
on "public"."log_extract"
as permissive
for select
to public
using (true);


create policy "reviewers_can_select_all_log_feedback"
on "public"."log_feedback"
as permissive
for select
to public
using (is_reviewer(auth.uid()));


create policy "user_update_own_log_infer"
on "public"."log_feedback"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Insert for authenticated users"
on "public"."log_images"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Select for all authenticated users"
on "public"."log_images"
as permissive
for select
to public
using (true);


create policy "Insert for authenticated users"
on "public"."log_inventory"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Select for all authenticated users"
on "public"."log_inventory"
as permissive
for select
to public
using (true);


create policy "user_update_own_log_llmcall"
on "public"."log_llmcall"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Reviewers can view all preference validations"
on "public"."log_preference_validation"
as permissive
for select
to public
using (is_reviewer(auth.uid()));


create policy "Users can insert their own preference logs"
on "public"."log_preference_validation"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can insert their own validations"
on "public"."log_preference_validation"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can view their own preference logs"
on "public"."log_preference_validation"
as permissive
for select
to public
using (((auth.uid() = user_id) OR is_reviewer(auth.uid())));


create policy "Service role access"
on "public"."recorded_sessions"
as permissive
for all
to public
using ((auth.role() = 'service_role'::text))
with check ((auth.role() = 'service_role'::text));


create policy "Admins can manage all assignments"
on "public"."review_assignments"
as permissive
for all
to public
using (is_admin(auth.uid()));


create policy "Reviewers can create assignments for themselves"
on "public"."review_assignments"
as permissive
for insert
to public
with check ((is_reviewer(auth.uid()) AND (reviewer_id = auth.uid())));


create policy "Reviewers can view their assignments"
on "public"."review_assignments"
as permissive
for select
to public
using ((is_reviewer(auth.uid()) AND (reviewer_id = auth.uid())));


create policy "Admins can manage all comments"
on "public"."review_comments"
as permissive
for all
to public
using (is_admin(auth.uid()));


create policy "Reviewers can add comments to any thread"
on "public"."review_comments"
as permissive
for insert
to public
with check (is_reviewer(auth.uid()));


create policy "Reviewers can view comments on any thread"
on "public"."review_comments"
as permissive
for select
to public
using ((is_reviewer(auth.uid()) OR is_admin(auth.uid())));


create policy "Admins can do everything with threads"
on "public"."review_threads"
as permissive
for all
to public
using (is_admin(auth.uid()));


create policy "Reviewers can update any thread"
on "public"."review_threads"
as permissive
for update
to public
using ((is_reviewer(auth.uid()) OR is_admin(auth.uid())))
with check ((is_reviewer(auth.uid()) OR is_admin(auth.uid())));


create policy "Reviewers can view any thread"
on "public"."review_threads"
as permissive
for select
to public
using ((is_reviewer(auth.uid()) OR is_admin(auth.uid())));


create policy "Admins can view all audit logs"
on "public"."role_audit_log"
as permissive
for select
to public
using (is_admin(auth.uid()));


create policy "Users can view their own audit log"
on "public"."role_audit_log"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "user_update_own_user_list_items"
on "public"."user_list_items"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Admins can view all roles"
on "public"."user_roles"
as permissive
for select
to public
using (is_admin(auth.uid()));


create policy "Only admins can modify roles"
on "public"."user_roles"
as permissive
for all
to public
using (is_admin(auth.uid()));


create policy "Users can view their own role"
on "public"."user_roles"
as permissive
for select
to public
using ((auth.uid() = user_id));

CREATE TRIGGER update_review_threads_updated_at BEFORE UPDATE ON public.review_threads FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

